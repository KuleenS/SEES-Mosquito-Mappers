# -*- coding: utf-8 -*-
"""image_processing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BzKOGnklfAvl81gExxMuKbnztZ7okA8_
"""

# Commented out IPython magic to ensure Python compatibility.
import cv2
import os
import numpy as np
from matplotlib.pyplot import imshow
# %matplotlib inline

def rgb_show(im):
    imshow(cv2.cvtColor(im, cv2.COLOR_BGR2RGB))
    
from numba import jit

@jit(nopython=True)
def too_unloaded_jit(im, unloaded_colors=np.array([[52, 115, 117], [36, 89, 72]]), threshold=10):
    i = 0
    for rows in im:
        for b,g,r in rows:
            for b_u, g_u, r_u in unloaded_colors:
                if b_u != b:
                    continue
                elif g_u != g:
                    continue
                elif r_u != r:
                    continue
                i += 1
                if i >= threshold:
                    return True
    return False
        

v_line_kernel = np.array([
    [0.4, 0.0, 0.4],
    [0.7, 0.0, 0.7],
    [0.4, 0.0, 0.4]
])
h_line_kernel = v_line_kernel.T

def kernel_mean(im, kernel):
    try:
        return np.einsum('ijk,ij->ijk', im, kernel).sum(axis=(0, 1))/kernel.sum()
    except ValueError:
        return np.einsum('jik,ij->jik', im, kernel).sum(axis=(0, 1))/kernel.sum()

def erase_v_line(im, cols, row_range=None, kernel=v_line_kernel):
    if row_range is None:
        y_lower, y_upper = 0, im.shape[0]
    else:
        y_lower, y_upper = row_range
        
    im[y_lower:y_upper, cols[1]] = np.asarray(
        [kernel_mean(im[y_lower:y_lower+2, cols], kernel[:2])] +
        [kernel_mean(im[i-1:i+2, cols], kernel) for i in range(y_lower+1, y_upper-1)] +
        [kernel_mean(im[y_upper-2:y_upper, cols], kernel[-2:])]
    )
    return im

def erase_h_line(im, rows, col_range=None, kernel=h_line_kernel):
    if col_range is None:
        x_lower, x_upper = 0, im.shape[1]
    else:
        x_lower, x_upper = col_range

    im[rows[1], x_lower:x_upper] = np.asarray(
        [kernel_mean(im[rows, x_lower:x_lower+2], kernel[:2])] +
        [kernel_mean(im[rows, i-1:i+2], kernel) for i in range(x_lower+1, x_upper-1)] +
        [kernel_mean(im[rows, x_upper-2:x_upper], kernel[-2:])]
    )
    return im

@jit(nopython=True)
def find_first(item, vec):
    for i, v in enumerate(vec):
        if v == item:
            return i
    return -1

def get_cat_and_ims(project_dir):
    
    for f in os.scandir(project_dir):
        if f.is_dir():
            
            cat = f.name
            images = [f.path for f in os.scandir(f) if f.is_file()]
            yield images, cat

while True:
    project_dir = input('Enter project directory: ')
    if os.path.isdir(project_dir):
        
        base_dir = project_dir.rsplit(os.path.sep, 1)[0]
        for new_dir in ['train', 'valid', 'test']:
            new_path = os.path.join(base_dir, new_dir)
            if not os.path.isdir(new_path):
                os.mkdir(new_path)
                print(f'Made new directory: {new_path}')
            else:
                print(f'Directory already exists: {new_path}\nDefaulting to existing directory')
        break
    else:
        print('Not a valid directory')

while True:
    
    splits = input('Enter train, valid, and test splits (based on ratios of 100, separated by " ") \
                   Ex. 75 15 10\n')
    
    try:
        
        splits = [int(s) for s in splits.split(' ', 3)]
        assert sum(splits) == 100
        break
    
    except ValueError:
        print('Splits must be 3 integers separated by spaces')
    
    except AssertionError:
        print('Splits must add up to 100')

from collections import deque

plurality = {1:''}
im_deque = deque()
cat_deque = deque()
dir_gen = get_cat_and_ims(project_dir)
while True:
    
    try:
        images, cat = next(dir_gen)
    except StopIteration:
        break
    
    for data_dir in ['train', 'valid', 'test']:
        new_path = os.path.join(base_dir, data_dir, cat)
        if not os.path.isdir(new_path):
            os.mkdir(new_path)
        
    
    num = len(images)
    print(f"Processing {num} image{plurality.get(num, 's')} in category {cat}")
    
    split_inds = np.asarray(list(range(num)))
    np.random.shuffle(split_inds)
    tr_ind = int(num*splits[0]/100)
    te_ind = tr_ind + int(num*splits[1]/100)
    
    tr_num = 0
    val_num = 0
    te_num = 0
    
    n = 0
    for path in images:
        
        im = cv2.imread(path)
        
        if too_unloaded_jit(im):
            base_path, name = path.rsplit(os.path.sep, 1)
            print(f'{name} (in {base_path}) is not fully loaded')
            continue
        
        dim_y, dim_x = im.shape[:2]
        center_y, center_x = dim_y//2, dim_x//2
        half_size_y, half_size_x = dim_y//10, dim_x//10
        # Transpose, first bool
        # Add, second bool
        h_kernel_range = (center_y-half_size_y, center_y+half_size_y)
        v_kernel_range = (center_x-half_size_x, center_x+half_size_x)
        kernel_dict = {
        
            (False, 0): im[h_kernel_range[0]:h_kernel_range[1], v_kernel_range[0]],
            (False, 1): im[h_kernel_range[0]:h_kernel_range[1], v_kernel_range[1]],
            (True, 0): im[h_kernel_range[0], v_kernel_range[0]:v_kernel_range[1]],
            (True, 1): im[h_kernel_range[1], v_kernel_range[0]:v_kernel_range[1]]
        
        }
    
        line_lower = np.array([15, 50, 35])
        line_upper = np.array([45, 255, 225])
        
        line_pixs = []
        for i, k in kernel_dict.items():
        
            hsvs = cv2.cvtColor(np.expand_dims(k, 0), cv2.COLOR_BGR2HSV)
            mask = cv2.inRange(hsvs, line_lower, line_upper)
            inds = np.argwhere(mask == 255)
        
            if len(inds) > 0:
        
                if i[0]:
        
                    x_offset = h_kernel_range[0]
                    y_offset = h_kernel_range[i[1]]
        
                else:
        
                    inds = np.fliplr(inds)
                    x_offset = v_kernel_range[0]
                    y_offset = v_kernel_range[i[1]]
        
                line_pixs.append([i[0], np.array([y_offset, x_offset]) + inds])
                
        if len(line_pixs) > 1:
            
            count = 0
            for line in line_pixs:
        
                i, coords = line
                y, x = coords[0]
                if not i:
                    if x < center_x:
                        lower, upper = 0, v_kernel_range[1]
                    else:
                        lower, upper = v_kernel_range[0], dim_x
            
                    hsvs = cv2.cvtColor(np.expand_dims(im[y, lower:upper], 0), cv2.COLOR_BGR2HSV)
                    mask = cv2.inRange(hsvs, line_lower, line_upper)
            
                    first_false = find_first(0, mask.flatten())
            
                    if first_false == -1:
                        im = erase_h_line(im, [y-1, y, y+1])
            
                    elif x < center_x:
                        if first_false >= x:
                            im = erase_h_line(im, [y-1, y, y+1], [0, first_false])
                            count += 1
                        else:
                            continue
                    else:
                        if first_false+center_x <= x:
                            im = erase_h_line(im, [y-1, y, y+1], [first_false+h_kernel_range[0], dim_x])
                            count += 1
                        else:
                            continue
                    
                else:
                    if y < center_y:
                        lower, upper = 0, h_kernel_range[1]
                    else:
                        lower, upper = h_kernel_range[0], dim_y
            
                    hsvs = cv2.cvtColor(np.expand_dims(im[lower:upper, x], 0), cv2.COLOR_BGR2HSV)
                    mask = cv2.inRange(hsvs, line_lower, line_upper)
                    first_false = find_first(0, mask.flatten())
            
                    if first_false == -1:
                        im = erase_v_line(im, [x-1, x, x+1])
            
                    elif y < center_y:
                        if first_false >= y:
                            im = erase_v_line(im, [x-1, x, x+1], [0, first_false])
                            count += 1
                        else:
                            continue
                    else:
                        if first_false+center_y <= y:
                            im = erase_v_line(im, [x-1, x, x+1], [first_false+v_kernel_range[0], dim_y])
                            count += 1
                        else:
                            continue
            
                if count >= 2:
                    break
            
        n += 1
        
        split_ind = find_first(n, split_inds)
        if split_ind < tr_ind:
            im_dir = 'train'
            im_num = tr_num
            tr_num += 1
        elif split_ind < te_ind:
            im_dir = 'valid'
            im_num = val_num
            val_num += 1
        else:
            im_dir = 'test'
            im_num = te_num
            te_num += 1
            
        cv2.imwrite(os.path.join(base_dir, im_dir, cat, f'{cat}_{im_num}.png'), im)

print('Finished processing')